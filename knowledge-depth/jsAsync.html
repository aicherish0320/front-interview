<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS 异步方法</title>
  </head>
  <body></body>
  <script>
    console.log('global begin')
    setTimeout(() => {
      console.log('timer1 invoke')
    }, 1800)
    setTimeout(() => {
      console.log('timer2 invoke')
      setTimeout(() => {
        console.log('inner invoke')
      }, 1000)
    }, 1000)
    console.log('global end')
  </script>
  <script>
    /*
      异步编程
      单线程 JavaScript 异步方案
      采用单线程模式工作的原因
      最早的设计初衷：最早 JavaScript 就是运行在浏览器端的脚本语言，目的是为了实现
        页面的动态交互，实现页面交互的核心是 DOM 操作，如果 JavaScript 不是单线程的
        就会出现线程同步问题，比如：一个线程删除某个元素，而另一个线程修改这个元素，
        浏览器就不知道以哪个线程为准
      单线程：JS执行环境中负责执行代码的线程只有一个
      解决耗时任务：JavaScript 将任务的执行模式分成了两种
      - 同步模式（Synchronous）
      - 异步模式（Asynchronous）
      # 同步模式
      代码中的任务依次执行，后一个任务必须要等前一个任务执行完毕才能去执行，代码的执行顺序
        和代码的书写顺序一致
      # 异步任务
      不会去等待这个任务的结束才开始下一个任务，开启后就立即往后执行下一个任务
        后续逻辑一般会通过回调函数的方式定义
      如果没有异步任务，单线程的 JavaScript 语言就无法同时处理大量的耗时任务
      代码执行顺序混乱
      运行环境提供的API是以同步或异步模式的方式工作
      # 回调函数
      所有异步编程方案的根基
      回调函数可以理解为一件你想要做的事情
      回调函数是由调用者定义，交给执行者执行的函数
      # Promise
      一种更优的异步编程统一方案
      直接使用传统回调方式去完成复杂的异步流程，会导致毁掉地狱
      CommonJS 社区提出了 Promise 的 规范 
      在 ES2015 中被标准化

    */
  </script>
</html>
